<HTML>
<BODY>
<b>HOBO</b> is a framework for building ontology-driven Java applications, wherein an in-memory Java-based model integrates an internal domain-specific <b>Java Object Model (OM)</b> with one or more external <b>Ontologies</b> (or ontology-like knowledge sources).

<b>HOBO Models</b> are in-memory Java-based models. These models are hybrid in two distinct senses:
<p>
<b>Hybrid sources:</b> Entities in HOBO models are derived from either, or both:
<ul>
  <li>Internal Java Object Model (OM)</li>
  <li>One or more external ontologies (or ontology-like knowledge sources)</li>
</ul>
<b>Hybrid access:</b> HOBO models are accessible via complimentary model-access APIs:
<ul>
  <li>Domain-specific API, as provided by domain-specific OM</li>
  <li>Generic domain-neutral frames-based API</li>
</ul>

<H1>Hybrid Model Sources</H1>
The domain concepts represented by the models will, in general, be derived from sources of two distinct types:
<ul>
  <li><b>Object Model:</b> Wherein domain concepts are represented directly via appropriate domain-specific Java classes, built from HOBO-specific component classes
  <li><b>Ontologies:</b> Covering any ontology-like knowledge sources for which a HOBO plugin exists, or can be built. (In general, this will mean declarative knowledge sources providing hierarchies of domain concepts, possibly in combination with associated reasoning mechanisms)
</ul>
In general the OM will cover a relatively small core section of the model, providing the central structure but representing only the most general domain concepts, whilst one or more ontologies (possibly of varying types) will provide the, generally vastly larger, body of detailed domain knowledge.
<p>
A small number of "key" entities (concepts, concept-relations and concept-attributes) will be represented both in the OM and the ontologies, with appropriate mappings being provided as part of the <b>HOBO configuration system</b>.
<p>
If required, HOBO can be used without an OM, in order to drive a completely generic application, with the model being derived entirely from the relevant set of ontologies. However an OM can offer two distinct advantages:
<ul>
  <li><b>Domain-specific API:</b> An OM can provide a suitable API for a client application that embodies explicit domain knowledge.
  <li><b>Procedural update-mechanisms:</b> An OM can provide procedural model-instantiation update mechanisms of a type that can not generally be expressed via standard ontology-like formalisms.
</ul>

<H1>Complimentary Model-Access APIs</H1>
The client is able to access the models via two distinct, yet complimentary, APIs:
<ul>
  <li><b>Object Model API:</b> The domain-specific API provided by the domain-specific OM.
  <li><b>Frames-Based API:</b> A generic, domain-neutral, frames-based representation, wherein concepts are represented via "frames" and concept-relations and concept-attributes via, respectively, concept-valued and data-valued "slots" on the relevant frames.
</ul>
The OM API provides the <b>Direct Representation</b>, generally covering only the core section of the model.
<p>
The frames-based API provides the <b>Indirect Representation</b>, covering the entire model, combining the section covered by the OM with any ontology-derived sections. There will generally be some overlap between the OM-derived and ontology-derived sections (with mappings defined via the HOBO configuration system, as mentioned above). In fact it may well be the case that the OM-derived section will be entirely subsumed by the ontology-derived sections. There may also be some overlap between various individual ontology-derived sections, with any such overlap being defined by identical entity identifiers.
<p>
All entities in the direct representation of the model (i.e. OM classes and fields) will be bound to corresponding entities in the indirect representation (i.e. concept-level frames and slots). Whenever instantiations are created or updated in either representation, corresponding actions will automatically occur in the other. (<i>Note:</i> In both representations, instantiation updates can either be provided directly by the client, or automatically by the model itself in response to other related updates that have occurred.)

<H1>Direct Model/Modeller APIs</H1>
The API that a specific HOBO-compliant OM provides to the client will consist of:
<ul>
  <li>Domain-specific OM classes (provided by the OM developer)
  <li>Generic OM-framework classes and interfaces (provided by HOBO)
</ul>
These generic OM-framework classes constitute the <b>Direct Model API</b>, and the collection of classes that are used by the OM developer in building the OM, but that are not visible to the client code, constitute the <b>Direct Modeller API</b>.

<H1>Frames/Direct Mechanism APIs</H1>
There are two <b>Mechanism APIs</b>, frames and direct, which are collectively responsible for:
<ul>
  <li>Loading of ontology-derived entities into frames-based representation (via suitable plugins)
  <li>Registration of appropriate ontological-reasoning plugins
  <li>Registration of relevant OM classes, for which corresponding entities will be loaded into frames-based representation
  <li>Definition of mappings between OM and ontology-derived entities
  <li>Building of resulting HOBO models
</ul>

<H1>HOBO API Packages</H1>
As described above, the HOBO API is actually a collection of APIs providing both model-access facilities for client code, and model creation/loading facilities for modelling/mechanism code. Each of these separate APIs is provided by a different package, and each is described below.
<p>
Within these packages, HOBO uses the following single-character class-name prefixes to distinguish the broad category into which a class falls:
<p>
Frames-based-representation model/mechanism entities:
<ul>
  <li><b>I:</b> Instance-level entities
  <li><b>C:</b> Concept-level entities
  <li><b>M:</b> Meta-level entities
  <li><b>F:</b> Non-level-specific entities
</ul>
Direct-representation model/modeller/mechanism entities:
<ul>
  <li><b>D:</b> All direct-representation component entities
</ul>
Additionally HOBO provides some general packages (containing exceptions, configuration-related classes, and various general utilities) within which the following prefixes are used:
<ul>
  <li><b>H:</b> General HOBO utility classes
</ul>

<H3>Frames Model API</H3>
<i>Package:</i> {@link uk.ac.manchester.cs.mekon.model}
<p>
Models are loaded into the API as a concept-level {@link uk.ac.manchester.cs.mekon.model.CFrame}/{@link uk.ac.manchester.cs.mekon.model.CSlot} network. Individual model-instantiations can then by created by the client in the form of instance-level {@link uk.ac.manchester.cs.mekon.model.IFrame}/{@link uk.ac.manchester.cs.mekon.model.ISlot} networks.
<p>
The instance-level networks are dynamic in that any client-provided value-updates for slots on a particular frame may trigger automatic updates to the slot-set for that frame. These updates can be of the following types:
<ul>
  <li>Addition/removal of slots
  <li>Updates to value-constraints for particular slots
  <li>Addition/removal of inferred values for particular slots
</ul>
Such updates will be provided either by generic ontology-related reasoning mechanisms, or by procedural mechanisms associated with the OM.

<H3>Direct Model API</H3>
<i>Package:</i> {@link uk.ac.manchester.cs.hobo.model}
<p>
Each OM class or interface (i.e. the entities that represent the individual domain-specific concepts) will implement or extend the {@link uk.ac.manchester.cs.hobo.model.DObject} interface. Each OM field (i.e. a field on an OM class that is itself part of the OM) will be represented by a {@link uk.ac.manchester.cs.hobo.model.DField} object, which is an abstract class whose concrete extensions are {@link uk.ac.manchester.cs.hobo.model.DCell} for representing single-valued fields and {@link uk.ac.manchester.cs.hobo.model.DArray} for multi-valued fields.
<p>
Each OM entity is bound to a corresponding entity in the frames-based model. OM classes are bound to specific {@link uk.ac.manchester.cs.mekon.model.CFrame} objects, and OM fields (at the class-level) are bound to specific {@link uk.ac.manchester.cs.mekon.model.CSlot} objects.
<p>
In addition to directly providing the core model representation, the OM also provides access to those ontology-derived sections of the model that it does not cover directly itself. For instance, in general the OM will only directly represent the higher-level concepts within specific hierarchies in which the detailed content is derived solely from the ontologies. So:
<ul>
  <li>An OM class that maps to a specific ontology concept, may be instantiated to represent a particular descendant of that concept, which is represented in the ontology but not in the OM.
  <li>In such a case, the relevant {@link uk.ac.manchester.cs.mekon.model.IFrame} object may have associated {@link uk.ac.manchester.cs.mekon.model.ISlot} objects that are not represented at the higher-level and therefore not bound to specific OM fields.
  <li>Similarly, the valid values for a concept-valued slot are defined by a root-concept as specified via an appropriate {@link uk.ac.manchester.cs.mekon.model.CFrame} object, which may or may not be bound to a corresponding OM class.
</ul>

<H3>Direct Modeller API</H3>
<i>Package:</i> {@link uk.ac.manchester.cs.hobo.modeller}
<p>
The abstract {@link uk.ac.manchester.cs.hobo.modeller.DObjectShell} class provides a skeleton implementation for {@link uk.ac.manchester.cs.hobo.model.DObject}, to be extended by the individual OM classes. These extensions are able to access mechanisms for the creation, initialisation, monitoring and updating of the associated OM fields (as represented via {@link uk.ac.manchester.cs.hobo.model.DField} and it's extensions).

<H3>Frames Mechanism API</H3>
<i>Package:</i> {@link uk.ac.manchester.cs.mekon.mechanism}
<p>
The {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder} class is responsible for building the frames-based model, which involves the following steps:
<ul>
  <li>Registration of set of section-builder plugins, one for each ontology
  <li>Invocation of registered section-builder plugins
  <li>Return of resulting {@link uk.ac.manchester.cs.mekon.model.CModel} object
</ul>
The section-builder plugins are instances of specific extensions of {@link uk.ac.manchester.cs.mekon.mechanism.CSectionBuilder}, with each such extension being responsible for loading ontologies of a specific type. The section-builders will use mechanisms accessible from {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder} to create and register an appropriate set of frame-based entities. The section-builders are also responsible for providing ontological-reasoning plugins, in the form of specific implementations of {@link uk.ac.manchester.cs.mekon.mechanism.IReasoner}, and attaching them to appropriate frames, over whose instantiations they will perform any required reasoning.
<p>
The registration of the section-builder plugins can be done either via the API or via the HOBO configuration system.

<H3>Direct Mechanism API</H3>
<i>Package:</i> {@link uk.ac.manchester.cs.hobo.mechanism}
<p>
The {@link uk.ac.manchester.cs.hobo.mechanism.DBuilder} class is a wrapper around {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder} and is responsible for:
<ul>
  <li>Registration of required OM packages
  <li>Registration of mappings between OM entities and ontology-derived entities
  <li>Registration (via wrapped {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder}) of special frames-model section-builder plugin to build the frames-based entities that will be bound to the OM entities
  <li>Registration (via wrapped {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder}) of frames-model section-builder plugins to build the frames-based entities that will be bound to ontology-entities
  <li>Invocation (via wrapped {@link uk.ac.manchester.cs.mekon.mechanism.CBuilder}) of all registered frames-model section-builder plugins, including special section-builder for OM-derived entities, to create {@link uk.ac.manchester.cs.mekon.model.CModel} object
  <li>Creation of resulting {@link uk.ac.manchester.cs.hobo.model.DModel} object (providing access to wrapped {@link uk.ac.manchester.cs.mekon.model.CModel} object)
</ul>
Along with the registration of the section-builder plugins, the registration of the OM classes and the specification of the entity mappings can done either via the API or via the HOBO configuration system.
</BODY>
</HTML>
